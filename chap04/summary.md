# 테스트조직

이 장에서는 다음의 주제를 다룬다.
- 준비-실행-단언을 사용하여 테스트를 가시적이고 일관성 있게 만드는 방법
- 메서드를 테스트하는 것이 아니라 동작을 테스트하여 테스트 코드의 유지 보수성을 높이는 방법
- 테스트 이름의 중요성
- @Before와 @After 애너테이션을 활용하여 공통 초기화 및 정리 코드를 설정하는 방법
- 거슬리는 테스트를 안전하게 무시하는 방법

## AAA로 테스트 일관성 유지

우리는 테스트 코드를 가시적으로 준비, 실행, 단언 부분으로 조직했다. 이것을 트리플-A(AAA)라고도 합니다. 또 각 부분을 명시적으로 식별하려고 주석을 넣기도 했지만 AAA관용어를 이해한 후에는 불필요해졌습니다.

AAA로는 다음 일을 할 수 있습니다.
- 준비(Arrange) : 테스트 코드를 실행하기 전에 시스템이 적절한 상태에 있는지 확인합니다. 객체들을 생성하거나 이것과 의사소통하거나 다른 API를 호출하는 것 등입니다. 드물지만 시스템이 우리가 필요한 상태로 있다면 준비 상태를 생략하기도 합니다.
- 실행(Act): 테스트 코드를 실행합니다. 보통은 단일 메서드를 호출합니다. 
- 단언(Assert): 실행한 코드가 기대한 대로 동작하는지 확인합니다. 실행한 코드의 반환값 혹은 그 외 필요한 객체들의 새로운 상태를 검사합니다. 또 테스트한 코드와 다른 객체들 사이의 의사소통을 검사하기도 합니다. 

테스트의 각 부분을 구별하는 빈 줄은 전체 테스트 코드를 훨씬 빠르게 이해하는데 필수적인 가시적 도구입니다. 때에 따라 네 번쨰 단계가 필요합니다.
- 사후(After) : 테스트를 실행할 때 어떤 자원을 할당했다면 잘 정리되었는지 확인해야 합니다. 

## 동작 테스트 vs 메서드 테스트

테스트를 작성할 때는 클래스 동작에 집중해야 하며 개별 메서드를 테스트한다고 생각하면 안 됩니다. 

단위 테스트를 작성할 떄는 먼저 전체적인 시각에서 시작해야 합니다. 개별 메서드를 테스트하는 것이 아니라 클래스의 종합적인 동작을 테스트해야 합니다.

## 테스트와 프로덕션 코드의 관계

JUnit 테스트는 검증 대상인 프로덕션 코드와 같은 프로젝트에 위치할 수 있습니다. 하지만 테스트는 주어진 프로젝트 안에서 프로덕션 코드와 분리해야 합니다. 프로덕션 코드를 배포할 것이지만 테스트는 일반적으로 그 뒤에 존재합니다. 

### 테스트와 프로덕션 코드 분리

- 테스트를 프로덕션 코드와 같은 디렉터리 및 패키지에 넣기.
- 테스트를 별도 디렉터리로 분리하지만 프로덕션 코드와 같은 패키지에 넣기 

이 부분에 대해서는 첫번쨰 항목인 '테스트를 프로덕션 코드와 같은 디렉터리 및 패키지에 넣기'를 주로 사용한다지만, 우리팀 같은 경우에는 test폴더 밑에 같은 패키지명을 사용하고 있다. 리플렉션을 이용하여 해당 패키지를 삭제하는 기능을 만들어야 한다고 이 책에서 말하고 있지만, 아무래도 이 부분은 처음에 만들어지는 그레이들 기반 프로젝트 구조에서 구현이 되어있는게 아닐까 싶다. 

### 내부 데이터 노출 vs 내부 동작 노출

비공개 코드를 호출하는 테스트는 그 자체로 구현 세부사항과 결속하게 됩니다. 이러한 세부 사항이 변경되면 기술적으로 공개적인 행동이 그대로라고 해도 테스트는 꺠질 수 있습니다. 

내부 행위를 테스트하려는 충동이 든다면 설계에 문제가 있는 것입니다. 묻혀 있는 수많은 흥미로운 행동은 거의 단일 책임 원칙을 어기게 됩니다. SRP는 어떤 클래스가 작고 단일 목적을 가져야 함을 의미하며, 가장 좋은 해결책은 흥미로운 private 메서드를 추출하여 다른 클래스로 이동하는 것입니다. 이렇게 하면 그 클래스의 유용한 public 메서드가 됩니다. 

## 집중적인 단일 목적 테스트의 가치

- 단언이 실패했을 때 실패한 테스트 이름이 표시되기 때문에 어느 동작에서 문제가 있는지 빠르게 파악할 수 있습니다.

- 실패한 테스트를 해독하는 데 필요한 시간을 줄일 수 있습니다. JUnit은 각 테스트를 별도의 인스턴스로 실행하기 떄문입니다. 따라서 현재 실패한 테스트에 대해 다른 테스트의 영향을 제거할 수 있습니다.

- 모든 케이스가 실행되었음을 보장할 수 있습니다. 단언이 실패하면 현재 테스트 메서드는 중단합니다. 단언 실패는 java.lang.AssertionError를 던지기 때문입니다.(JUnit은 이것을 잡아 테스트를 실패로 표시합니다.). 

## 문서로서의 테스트

### 일관성 있는 이름으로 테스트 문서화

테스트하려는 맥락을 제안하기 보다는 어떤 맥락에서 일련의 행동을 호출했을 때 어떤 결과가 나오는지를 명시하세요.

|멋지지 않은 이름|멋지고 설명적인 이름|
|---|---|
|makeSingleWithdrawal|withdrawalReducesBalaceByWithdrawnAmount|
|attemptToWithdrawTooMuch|withdrawalOfMoreThanAvailableFundsGenerateError|
|multipleDeposits|multipleDepositsIncreaseBalanceBySumOfDeposits|

멋지고 설명적인 이름은 다음 양식을 따릅니다.
doingSomeOperationGenerateSomeResult
(어떤 동작을 하면 어떤 결과가 나온다.)

someResultOccursUnderSomeCondition
(어떤 결과는 어떤 조건에서 발생한다.)

혹은, 행위 주도 개발(BDD, Behavior-Driven Development)에서 말하는 given-when-then 양식을 사용할 수도 있습니다.(우리팀에서는 이 양식을 사용하고 있다.)

givenSomeContextWhenDoingSomeBehaviorThenSomeResultOccurs


### 테스트를 의미있게 만들기

다른사람이 테스트를 파악하기 어려워 한다면 다음을 고려해 봐라.
- 지역 변수 이름 개선하기
- 의미 있는 상수 도입하기
- 햄크레스트 단언 사용하기
- 커다란 테스트를 작게 나누어 집중적인 테스트 만들기
- 테스트 군더더기들을 도우미 메서드와 @Before 메서드로 이동하기


## @Before와 @After(공통 초기화와 정리) 더 알기

@Before 메서드는 매번 테스트 메서드 실행에 앞서 실행됩니다. 주의할 점은 다수의 @Before메서드가 있을때 실행의 순서는 보장하지 않는다.

@After 메서드는 클래스에 있는 각 테스트를 한 후에 실행되며, 테스트가 실패하더라도 실행됩니다. @After 메서드는 테스트에 발생하는 부산물들을 정리하는 역할을 합니다.

### BeforeClass와 AfterClass 애노테이션

매우 드문 경우에만 테스트 클래스 수준의 초기화인 @BeforeClass가 필요합니다. 이것은 클래스에 있는 어떤 테스트를 처음 실행하기 전에 한 번만 실행됩니다. JUnit은 그와 정반대인 @AfterClass 애너테이션도 제공합니다.

다음은 실행 흐름입니다.
```
@BeforeClass
@Before
@Test
@After
@Before
@Test
@After
@AfterClass
```

## 녹색이 좋다: 테스트를 의미 있게 유지

실패하는 테스트가 있다면 더 늘리지 마세요! 실패하면 곧바로 고쳐서 모든 테스트가 항상 통과하도록 해야 합니다. '항상 녹색으로'가 프로덕션 코드를 변경해야 할 떄 코드에 오류가 없도록 지켜 줍니다.

### 테스트를 빠르게

테스트 코드에 db처럼 느린 자원을 통제하는 부분이 없다면 수 초 안에 수천 개의 테스트를 실행하는 것이 가능합니다. 이 속도라면 전체 테스트를 항상 실행하는 것이 어렵지 않습니다. 이클립스와 호환되는 IDE에서는 항상 모든 테스트를 프로젝트에서 마우스 오른쪽 버튼을 누르고 그 수준에서 테스트를 실행하기만 하면 됩니다. 
(음,,, 계속 읽다보니,, 결론은,,, 견딜수 있는 개수만큼만 테스트를 하란 거네,,?? ㅠ )

@Ignore 메서드를 사용하면 테스트에서 제외되도록 할 수도 있는 것으로 보인다.