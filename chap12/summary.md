# 테스트 주도 개발

- TDD의 주된 이익
- 단순하게 시작
- 또 다른 증분 추가
- 테스트 정리
- 또 다른 작은 증분
- 다수의 응답 지원: 작은 설계 우회로
- 인터페이스 확장
- 마지막 테스트들
- 문서로서의 테스트
- TDD의 리듬
- 마치며

작성하려는 코드가 있다면 항상 먼저 어떻게 그 코드를 테스트할지 고민해야 합니다. 코드를 작성한 후에 어떻게 테스트할지 고민하기보다 작성할 코드를 묘사하는 테스트를 설계해야 합니다. 이러한 역방향 접근법은 기이하거나 심지어 불가능해 보일수도 있습니다. 하지만 이것이 테스트 주도 개발에 기반을 둔 단위 테스트 전략의 핵심입니다.

우리는 TDD에서 단위테스트를 시스템의 모양을 잡고 통제하는 도구로 활용해야 합니다. 단위 테스트는 종종 잘 선별한 후 한쪽에 치워 놓고 나중에 반영하려는 코드가 될 수 있는데, 단위 테스트는 소프트웨어를 어떻게 만들어야 할지에 관한 잘 훈련된 사이클의 핵심적인 부분입니다. 따라서 TDD를 채택하면 소프트웨어 설계는 달라지고, 아마도 더 좋아질 것입니다.

---
## TDD의 주된 이익
단위테스트를 사후에 작성하여 얻을 수 있는 가장 분명하고 명확한 이익은 코드가 예상한 대로 동작한다는 자신감을 얻는 것입니다. TDD에서도 동일한 이익과 그 이상을 얻을 수 있습니다.

코드를 깨끗하게 유지하도록 치열하게 싸우지 않으면 시스템은 대개 점점 퇴화합니다. 코드를 재빠르게 추가할 수는 있지만 처음에는 좋은 코드라기 보다는 그다지 위대하지 않은 코드일 가능성이 높습니다.

- 우리는 다음 업무로 바로 넘어가야 해요. 코드에 금박을 입힐 시간이 없어요
- 제 생각에 코드를 있는 그대로도 잘 읽을 수 있어요. 제가 작성했고 제가 이해하거든요. 로직이 분명하지 않다면 주석을 조금 추가하면 되어요.
- 그 부분에서 좀 더 큰 변화가 필요할 때 코드를 리팩토링하면 되어요
- 잘 동작합니다. 왜 좋은 것에 메스를 들어야 하죠? 깨지지 않으면 코드는 수정하지 않습니다. 코드를 리팩토링하다가 다른 코드를 망가트리기 쉬워요.

그러나 리팩토링은 위험 부담이 있는 일이기도 하고 우리는 일견 위험하지 않아 보이는 변경을 할 때도 실수를 많이 하고는 합니다. 하지만 TDD를 잘 따른다면 구현하는 실질적인 모든 사례에 대해 단위테스트를 작성하게 됩니다. 이러한 단위 테스트는 코드를 지속적으로 발전시킬 수 있는 자유를 줍니다.

## 단순하게 시작
TDD는 세 부분의 사이클로 구성됩니다.
- 실패하는 테스트 코드 작성하기
- 테스트 통과시키기
- 이전 두 단계에서 추가되거나 변경된 코드 개선하기

## 또 다른 증분 추가

실패하는 각 테스트에 대해 그 테스트를 통과할 수 있는 코드만 추가하세요. 가능한 가장 작은 증분을 추가하는 것입니다. 사고방식은 다음과 같습니다. 테스트가 나타내는 '명세'를 정확히 코딩하세요. 테스트가 모두 통과한다면 코드를 배포할 수 있습니다. 그 지점에서 테스트는 시스템이 무엇을 하는지도 문서화 합니다. 

TDD 사이클에 따르는 좀 더 실용적인 관점에서 가장 작은 양의 코드를 작성하는 것은 대부분 먼저 실패하는 또 다른 테스트를 만들 수 있다는 의미입니다. 필요한 것보다 더 많은 코드를 작성하는 것은 즉시 통과할 수 있는 많은 테스트를 스스로 만들 수 있다는 의미입니다.

## 테스트 정리

TDD 사이클에서 두 번째 테스트를 통과한 후에 코드를 정리하기로 했습니다. 비슷한 테스트 메서드가 한 클래스내에 두개가 있는데, Arrange과정에서 공통으로 사용하는 인수의 경우 @Before 메서드에서 공통 초기화를 합니다.

```
TDD는 거의 모든 코드에 안전한 리팩토링을 가능하게 합니다.
```

대부분의 리팩토링은 쉽지만 효과가 큽니다. 변수 이름을 변경하는 것은 독자에게 커다란 정보를 줍니다. 작은 코드 조각을 의도를 알 수 있는 이름의 도우미 메서드로 추출하면 마찬가지로 테스트를 향상시키는데 많은 도움이 됩니다.

## 또 다른 작은 증분

TDD로 생각하는 부분의 일부는 작성할 필요가 있는 다음 테스트를 결정하는 것입니다. 프로그래머로서 임무는 코드가 다루어야 하는 모든 가능한 순열과 시나리오를 이해하는 것입니다. TDD로 성공하려면 이들 시나리오를 테스트로 만들고 각 테스트를 통과하게 만드는 코드 증분을 최소화하는 순으로 코드를 작성하는 것입니다.

## 다수의 응답 지원: 작은 설계 우회로

TDD를 할 때 다른 코드를 전혀 건드리지 않고 해당 클래스만 변경할 필요는 없습니다. 필요한 사항이 있다면 설계를 변경하여 다른 클래스로 넘어가도 됩니다.

## 인터페이스 확장

TDD가 항상 최상의 설계를 마법처럼 만들어 내지는 않음을 기억합니다. 우리에게는 테스트들이 있고 이를 활용하여 원할 떄 더나은 설계로 리팩토링할 수 있습니다.

## 마지막 테스트들

코드를 만들어 나가면서 추가된 테스트들로 인해 필요없어진 테스트들은 제거를 진행합니다.

## 문서로서의 테스트

마지막 작업으로 테스트클래스에 있는 테스트 메서드들의 이름들을 살펴봅니다.

Before

```
matchesWhenProfileContainsMatchingAnswer
doesNotMatchWhenNoMatchingAnswer
matchesWhenContainsMultipleAnswers
doesNotMatchWhenNoneOfMultipleCriteriaMatch
matchesWhenAnyOfMultipleCriteriaMatch
doesNotMatchWhenAnyMustMeetCriteriaNotMet
matchesWhenCriterionIsDontCare
scoreIsZeroWhenThereAreNoMatches
```

테스트 이름은 나쁘지 않지만 더 좋아질 수 있습니다. 테스트들은 ProfileTest클래스의 일부이므로 Profile 객체들을 테스트합니다. 따라서 각 테스트 이름에서 Profile을 제거할 수 있습니다. 또 matches() 메서드의 오버롣드 형태는 인자에 따라 단일 Criterion 객체를 받는지 컬렉션인 Criteria를 받는지에 따라 구별합니다. 

```
matchesCriterionContainsMatchingAnswer
doesNotMatchCriterionWhenNoMatchingAnswerContained
matchesCriterionWhenOneOfMultipleAnswerMatches
doesNotMatchCriteriaWhenNoneOfMultipleCriteriaMatch
matchesCriteriaWhenAnyOfMultipleCriteriaMatch
doesNotMatchWhenAnyMustMeetCriteriaNotMet
alwaysMatchesDontCareCriterion
scoreIsZeroWhenThereAreNoMatches
```
또, 한 클래스에 모두 넣을 필요는 업습니다. 각 테스트 클래스 혹은 고정물로 나누면 연관된 동작 그룹에 집중할 수 있습니다.

```
class Profile_MatchesCriterionTest{
    @Test public void trueWhenMAtchesSoleAnswers()
    ..
}
class Profile_MatchesCriteriaTest{
    
    ..
}
class Profile_ScoreTest {
    ..
}
```
*정기적으로 테스트 이름이 서로 어울리는지 확인합니다.*

## TDD의 리듬

TDD의 사이클은 짧습니다.테스트-코드-리팩토링의 각 사이클은 몇 분이면 됩니다. 각 단계에서 추가되거나 변경된 코드 증분도 비교적 작습니다.
우리가 TDD의 리듬을 형성하면 돌익킬 수 없는 쥐구멍으로 빨려 들어갈 것이 분명합니다. 약 10분 정도의 시간 제한을 걸어봅니다. 10분 동안 어떤 긍정적인 피드백을 받지 못한다면 작업중인 코드는 폐기하고 다시 좀 더 작은 단계를 도전합니다.
나쁜 코드는 버립니다. 각 TDD의 사이클은 테스트를 가설로 한 시간 제한이 있는 실험으로 취급합니다. 실험이 엉망이 되었다면 다시 시작하여 가정의 범위를 축소하면 무엇이 잘못되었는지 찾는데 도움이 될 것입니다.

## 마치며
테스트를 작성하고, 그것을 통과하고 코드가 깔끔한지 확인하며 반복하는것. 그것이 TDD입니다.
TDD를 도입하면 설계에 대해 생각하는 방식이 바뀝니다.

책상으로 돌아가 단위 테스트에 대해 배운 것을 실무에 적용하기 시작하면 틀림없이 다음과 같은 상황에 직면합니다.
```
저런 것은 도대체 어떻게 테스트하지?
```
이에 대한 대답을 찾도록 합니다.

