# 좋은 테스트의 FIRST 속성

테스트에 다음 문제점이 있다면 우리의 시간과 수면 시간은 부족해질 것이다.

- 테스트를 사용하는 사람에게 어떤 정보도 주지 못하는 테스트
- 산발적으로 실패하는 테스트
- 어떤 가치도 증명하지 못하는 테스트
- 실행하는 데 오래 걸리는 테스트
- 코드를 충분히 커버하지 못하는 테스트
- 구현과 강하게 결합되어 있는 테스트, 따라서 작은 변화에도 다수의 테스트가 깨진다.
- 수많은 설정 고리로 점프하는 난해한 테스트

## FIRST: 좋은 테스트 조건

- Fast: 빠른
- Isolated: 고립된
- Repeatable: 반복 가능한
- Self-validating: 스스로 검증 가능한
- Timely: 적시의 

## [F]ast: 빠르다

빠른 테스트는 코드만 실행하며 소요 시간은 수 밀리초 수준입니다. 느린 테스트는 데이터베이스, 파일, 네트워크 호출처럼 필요한 외부 자원을 다루는 코드를 호출합니다. 실행 시간은 수십. 수백. 수천 밀리초가 걸리기도 합니다.

테스트를 빠르게 유지하기 위해 느린 테스트에 대한 의존성을 줄인다.

## [I]solate : 고립시킨다.

테스트 대상 코드는 데이터베이스를 읽는 다른 코드와 상호 작용할 수도 있습니다. 데이터 의존성은 많은 문제를 만듭니다. 궁극적으로 데이터베이스에 의존해야 하는 테스트는 데이터베이스가 올바른 데이터를 가지고 있는지 확인해야 합니다. 

좋은 단위테스트는 다른 단위테스트에 의존하지 않습니다.

SRP에 따르면 클래스는 작고 단일한 목적을 가져야 합니다. 좀 더 구체적으로 SRP는 클래스를 변경해야 할 이유가 하나만 있어야 한다고 말합니다.

## [R]epeatable : 좋은 테스트는 반복 가능해야 한다.

반복가능한 테스트는 실행할 때마다 결과가 같아야 합니다. 따라서 반복 가능한 테스트를 만들려면 직접 통제할 수 없는 외부 환경에 있는 항목들과 격리시켜야 합니다.

그런데, 예를들면 타임스탬프는 움직이는 표직이어서 특정 타임스탬프를 단언하는 것은 어려운 일입니다. 시간은 멈출수 없기에,, 코드상에서 고정된 시간을 반환할 수 있는 트릭을 사용하여 이러한 문제를 해결할 수 있습니다.

## [S]elf Validate: 스스로 검증 가능하다.

테스트 결과를 수동으로 검증하는 것은 시간 소모적인 절차고 리스크가 늘어납니다. 멍해지기 쉽고 코드가 출력해 내는 거대한 로그를 보다가 중요한 신호를 놓칠 수도 있습니다. 

테스트에 필요한 어떤 설정 단계든 자동화를 해야 합니다. 그럼에도 테스트를 실행하는데 외부 설정이 필요하다면 FIRST중에 I부분(고립성)을 위반하는 것입니다.

## [T]imely: 적시에 사용한다.

시스템에 있는 오래된 부분에 코드를 추가하고 거기서 단위 테스트를 시작할 수도 있습니다. 가능하면 적절한 순간에 단위 테스트에 집중하는 것이 낫습니다.

단위 테스트로 코드를 검증하는 것을 미룰수록 치석(불쾌한)이 끼고 충치(결함)가 늘어날 것입니다. 또 코드를 소스 저장소에 넣으면 그것을 되돌려 테스트를 작성하기는 더욱 힘들어 집니다.

---
단위 테스트를 작성한는 것은 상당한 시간이 필요합니다. 테스트 코드가 그에 상응하는 가치가 있다고 해도 이러한 테스트 코드 또한 여러분이 유지 보수해야 합니다. 테스트 코드를 고품질로 유지하여 이러한 투자를 보호하세요. 그리고 FIRST 두문자를 이용하여 좋은 테스트 속성을 기억합니다.