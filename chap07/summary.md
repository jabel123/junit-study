# 경계 조건 : CORRECT 기억법

단위 테스트는 종종 경계 조건들에 관계된 결함들을 미연에 방지하는데 도움이 됩니다. 경계 조건은 행복 경로의 끝에 있는 것으로 자주 문제가 발생합니다.

CORRECT약어로 그 조짐을 알아낼 수 있으며, 이 약어는 단위테스트를 만들 때 고려해야할 경계 조건들을 생각하는 데도 도움이 됩니다.

- [C]onformance(준수) : 값이 기대한 양식을 준수하고 있는가?
- [O]rdering(순서) : 값의 집합이 적절하게 정렬되거나 정렬되지 않았나?
- [R]ange(범위) : 이성적인 최솟값과 최댓값 안에 있는가?
- [R]eference(참조) : 코드 자체에서 통제할 수 없는 어떤 외부 참조를 포함하고 있는가?
- [E]xistence(존재) : 값이 존재하는가(널이 아니거나(non-null), 0이 아니거나(non-zero), 집합에 존재하는가 등)
- [C]ardinality(기수) : 정확히 충분한 값들이 있는가?
- [T]ime(절대적 혹은 상대적 시간) : 모든 것이 순서대로 일어나는가? 정확한 시간에? 정시에?

각 CORRECT조건에 대해 넘겨진 인수, 필드와 지역적으로 관리하는 변수들까지 가능한 모든 발생 원인이 데이터에 미칠영향을 고려합니다.  
잘못된 수 있는 어떤 것이라도 떠오르면 테스트 이름을 적어놓으세요. 그리고 시간이 있다면 테스트에 살을 붙입니다. 한 가지 가능한 오류 시나리오를 생각해 두면 종종 연계되는 다른 시나리오도 떠올릴 수 있습니다. 

---
## [C]onfermance : 준수

많은 데이터 요소가 특정 양식을 따라야 합니다. 예를 들어 이메일 주소는 일반적으로 다음과 같은 형식입니다.
```
name@somedomain
```
이메일 주소, 전화번호, 계좌번호, 파일 이름 등 양식 있는 문자열 데이터를 검증할 때는 많은 규칙이 필요합니다. 

구조적 데이터의 경우 테스트 케이스를 조합하면 그 수가 폭발적으로 늘어나기도 합니다.
헤더 기록, 몇 개의 데이터 기록과 트레일러 기록으로 구성된 보고 자료를 읽는다고 합시다.  테스트해야 할 경계 조건은 다음과 같습니다.
- 헤더가 없습니다. 데이터와 트레일러만 존재합니다.
- 데이터가 없습니다. 헤더와 트레일러만 존재합니다.
- 트레일러가 없습니다. 헤더와 데이터만 존재합니다.
- 트레일러만 있습니다.
- 헤더만 있습니다.
- 데이터만 있습니다. 

계좌 번호 같은 필드는 시스템에 있는 수많은 메서드에 넘겨질 것입니다. 하지만 시스템에 그 필드가 처음 입력될 때 검증한다면 그 필드를 인자로 넘길 때마다 검사하지 않아도 됩니다. 이처럼 시스템의 데이터 흐름을 이해하면 불필요한 검사를 최소홯할 수 있습니다. 

---
## [O]rdering(순서)

데이터 순서 혹은 커다락 컬렉션에 있는 데이터 한 조각의 위치는 코드가 쉽게 잘못될 수 있는 CORRECT조건에 해당합니다.

---
## [R]ange(범위)

자바 기본형으로 변수를 만들 때 대부분은 필요한 것보다 훨씬 많은 용량을 가집니다. int타입으로 사람 나이를 표현한다면 적어도 수백만 세기를 표현할 만큼 충분합니다. 불필요하게 잘못될 가능서이 생깁니다. 예를들어 므두셀라보다 훨씬 나이 많은 사람이 나오거나 나이가 음수인 시간을 거슬러 올라간 사람을 만들 수 있습니다.  
기본형의 과도한 사용에 대한 코드 냄새를 기본형 중독이라고 합니다. 자바 같은 객체지향언어의 장점은 사용자 정의 추상화를 클래스로 만들 수 있다는 것입니다. 


### 불변성을 검사하는 사용자 정의 매처 생성

@After메서드에 있는 단언은 constrainsSidesTo 라는 사용자 정의 햄크레스트 매처를 사용합니다. 매처는 왼쪾에서 오른쪽으로 읽었을 때 잘 읽히는 단언을 표현합니다.

사용자 정의 햄크레스트 매처를 구현하려면 org.hamcrest.TypeSafeMatcher클래스를 상속하여 매칭하고자 하는 타입을 지정합니다.

클래스는 matchesSafely를 오버라이드 해야합니다. matchesSafely()메서드에 제약 사항이 포함됩니다. 사각형의 각 변이 범위에 있으면 true를 반환합니다. 제약을 어기면 false를 반환합니다. 사용자 정의 매처 클래스는 단언이 실패할 떄 제공할 의미 있는 메시지를 describeTo()메서드에 기재해야 합니다.

### 불변 메서드를 내자하여 범위 테스트

테스트할 대부분의 범위는 애플리케이션-도메인 제약이라기보다는 자료 구조에 관한 제약에 의존하게 될 것입니다.  
희소 배열(sparse array)에 관한 의심스러운 구현을 살펴봅니다. 희소 배열은 저장 공간을 줄이는 목적으로 설계된 자료 구조입니다. 희소 배열을 위한 핵심 지점은 대응되는 값이 대부분 null인 넓은 범위의 인덱스들입니다. null이 아닌 값을 저장하고 값 배열과 합을 이루는 인덱스들의 배열을 쌍으로 저장하여 이러한 목적을 달성합니다.

인ㄷ겟싱은 수많은 잠재적인 오류를 포함하고 있습니다. CORRECT 약어의 Range(범위) 부분 마지막 노트로 인덱스를 다룰 때 고려해야 할 몇 가지 테스트 시나리오는 다음과 같습니다.
- 시작과 마지막 인덱스가 같으면 안됩니다.
- 시작이 마지막보다 크면 안됩니다.
- 인덱스는 음수가 아니어야 합니다.
- 인덱스가 허용된 것보다 크면 안 됩니다.
- 개수가 실제 항목 개수와 맞아야 합니다.

---
## [R]eference(참조)

어떤 메서드를 테스트할 때는 다음을 고려해야 합니다.
- 범위를 넘어서는 것을 참조하고 있지 않은지
- 외부 의존성은 무엇인지
- 특정 상태에 있는 객체를 의존하고 있는지 여부
- 반드시 존재해야 하는 그 외 다른 조건들

어떤 상태에 대해 가정할 때는 그 가정이 맞지 않으면 코드가 합리적으로 잘 동작하는지 검사해야 합니다. 자동차의 마이크로 프로세서로 동작하는 변속기 관련 콛를 개발중이라고 합시다.    
차량이 이동중일 떄와 그렇지 않을 떄 변속기 동작이 어떻게 달라지는지 테스트 하고자 합니다. Transmission클래스의 테스트 코드는 세 가지 중대한 시나리오를 다루고 있스니다. '가속 이후에 변속기를 주행으로 유지하는가', '주행중에 주차로 바꾸는 파괴적인 요청을 무시하는가', '차량이 움직이지 않으면 주차로 변속기 변경을 허용하는가'입니다.

---
## [E]xistence(존재)

스스로에게 "주어진 값이 존재하는가?" 라고 물어봄으로써 많은 잠재적인 결함을 발견할 수 있습니다. 어떤 인자를 허용하거나 필드를 유지하는 메서드에 대해 그 값이 null, 0 혹은 비어있는 경우라면 어떤 일이 일어날지 생각해 봅니다.

---
## [C]ardinality(기수)

울타리 기둥 오류: 한 끗 차이로 발생하는 수 많은 경우 중 한 가지를 의미하며, 종종 한 곳 혹은 다른 곳에서 치명적인 상태가 되고는 하는 오류.

0-1-n법칙을 기억한다.. 
### 0-1-n 법칙 예제
- 목록에 항목이 하나도 없을 때 보고서 출력하기
- 목록에 항목이 한 개만 있을 때 보고서 출력하기
- 목록에 항목이 없을 때 한 항목 추가하기
- 목록에 항목이 하나만 있을 떄 한 항목 추가하기
- 목록에 항목이 열 개 미만일 때 한 항목 추가하기
- 목록에 항목이 이미 열 개가 있을 때 한 항목 추가하기
--- 

## [T]ime(시간)

시간에 관하여 마음에 담아 두어야 할 측면 몇 개는 다음과 같습니다.
- 상대적 시간(시간 순서)
- 절대적 시간(측정된 시간)
- 동시성 문제들

상대적인 시간은 타임아웃 문제도 포함할 수 있습니다. 수명이 짧은 자원에 대해 코드가 얼마나 기다릴 수 있는지 결정해야 합니다. 타임아웃 등을 포함하여 코드에서 가능한 조건들을 시뮬레이션해 보고 싶을 수도 있습니다. 타임아웃으로 보호되지 않는 조건들을 찾아봅니다. 이를테면 바생하지 않을 일을 기다리느라 코드가 무한 대기에 빠지지는 않는지 확인합니다.

멀티스레드이면서 동시적인 프로그램을 설계하고 구현하고 디버깅하는 것은 별도로 도서 한 권이 필요한 수준으로 다음의 질문에 스스로 물어보는 것부터 시작한다.

- 동시에 같은 객체를 다수의 스레드가 접근한다면?
- 어떤 전역 혹은 인스턴스 수준의 데이터나 메서드에 동기화를 해야하는가?
- 파일 혹은 하드웨어에 외적인 접근은 어떻게 처리해야 할까?



